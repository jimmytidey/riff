package {	import fl.controls.TextInput;	import flash.events.*;	import flash.display.*;	import flash.text.TextField;	import fl.controls.Button;	import flash.media.SoundMixer;	import flash.media.SoundChannel;	public class PlayBack extends MovieClip{				public var step_time:Number; //indicates the length of time each step plays for 		public var step_number:int = 0; //indicates which step the timer is currently on		public var reload_sounds:int = 1; ////use this to check if we need to recreate all the sound objects		public var play_status:int = 0;		public var jsonData:Object;		public var grid:Object;		public var soundContainer:Object;		public var volumeArray:Array;		//other useful objects 		var myTimer:AccurateTimer = new AccurateTimer(0, 1000);			var render:Render = new Render();				function PlayBack(jsonData, volumeArray, _stage,  grid_top, grid_left) {			render.drawPlayhead(jsonData, _stage, 0,  grid_top, grid_left);		}				public function go(jsonData, volumeArray, grid, soundContainer) {			this.jsonData = jsonData;			this.grid = grid;			this.volumeArray = volumeArray;			this.soundContainer = soundContainer;			calculateStepTime();			SoundMixer.stopAll(); // stop it from playing two things at once			myTimer.start();			play_status = 1;			playStep();		}				public function calculateStepTime() {			var beats_per_second:Number = jsonData['project_info']['bpm']/60;			var seconds_per_beat:Number = 1/beats_per_second; 			step_time = (seconds_per_beat * jsonData['project_info']['bpl'])*1000; 			trace(step_time);			myTimer = new AccurateTimer(step_time, 1000);			myTimer.addEventListener(TimerEvent.TIMER, step);		}						public function step(event:TimerEvent) {			trace("STEP");			step_number++;			playStep();		}									public function my_stop() {			trace('stop called');			play_status = 0; 			myTimer.stop(); 			SoundMixer.stopAll();		}				public function movePlayHead(position) {			step_number = position;			render.movePlayhead(step_number);		}				public function playStep() {			if (step_number == jsonData['project_info']['steps']) { //stop playback if we've got to the end of the track				 my_stop();			}						else {				render.movePlayhead(step_number);				trace('STEP NO = ' + step_number);								for (var bank_index:int =0; bank_index < jsonData['banks'].length; bank_index++) {					for (var bank_option_index:int =0; bank_option_index < jsonData['banks'][bank_index]['bank_options'].length; bank_option_index++) {												var file_location = jsonData['banks'][bank_index]['bank_options'][bank_option_index]['file_location'];						file_location  = file_location.split(".");						var clean_file_location = file_location[0];												if (step_number > 0) {							previous_step = step_number-1;							//unusual runon situation							if (jsonData['banks'][bank_index]['bank_options'][bank_option_index]['loop'] == 'true' && grid[bank_index][step_number][bank_option_index] == 100 && grid[bank_index][previous_step][bank_option_index] == 100) {								trace(bank_index+' runon'); 							}														//just treat things as normal 							else { 																	if (jsonData['banks'][bank_index]['bank_options'][bank_option_index]['overplay'] == "false" && jsonData['banks'][bank_index]['bank_options'][bank_option_index]['sound']) {									trace("stopping all sounds which are not overplaying");									jsonData['banks'][bank_index]['bank_options'][bank_option_index]['sound'].stop();								}																			if (jsonData['banks'][bank_index]['bank_options'][bank_option_index]['overplay'] == "true") { 									trace('overplay detected');								}																//play any sounds which are set this time								if (grid[bank_index][step_number][bank_option_index] == 100) { 									trace(bank_index+' start'); 									volumeArray[bank_index][bank_option_index] = soundContainer[clean_file_location].play();									volumeArray[bank_index][bank_option_index].soundTransform =volumeArray[bank_index][bank_option_index];								}															}						}												//this for the first step of the composition 						else {							//play any sounds which are set this time							if (grid[bank_index][step_number][bank_option_index] == 100) {								trace("volume array:"+ volumeArray);  								jsonData['banks'][bank_index]['bank_options'][bank_option_index]['sound'] = soundContainer[clean_file_location].play();								jsonData['banks'][bank_index]['bank_options'][bank_option_index]['sound'].soundTransform = volumeArray[bank_index][bank_option_index];							}						}					}				}			}		}			}}